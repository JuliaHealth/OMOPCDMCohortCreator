var documenterSearchIndex = {"docs":
[{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"This is a list of documentation associated with every single exported function from OMOPCDMCohortCreator. There are a few different sections with a brief explanation of what these sections are followed by relevant functions.","category":"page"},{"location":"api/","page":"API","title":"API","text":"Pages = [\"api.md\"]","category":"page"},{"location":"api/#Getters","page":"API","title":"Getters","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"This family of functions are dedicated to only getting information concerning a patient or OMOP CDM database.","category":"page"},{"location":"api/","page":"API","title":"API","text":"GetDatabasePersonIDs\nGetPatientState\nGetPatientGender\nGetPatientRace\nGetPatientEthnicity\nGetPatientAgeGroup\nGetPatientVisits\nGetMostRecentConditions\nGetMostRecentVisit\nGetVisitCondition\nGetDatabaseYearRange\nGetDrugExposureIDs\nGetDrugConceptIDs\nGetDrugAmounts\nGetDatabaseCohorts\nGetCohortSubjects\nGetCohortSubjectStartDate\nGetCohortSubjectEndDate\nGetVisitProcedure\nGetDrugExposureEndDate\nGetDrugExposureStartDate","category":"page"},{"location":"api/#OMOPCDMCohortCreator.GetDatabasePersonIDs","page":"API","title":"OMOPCDMCohortCreator.GetDatabasePersonIDs","text":"GetDatabasePersonIDs(conn; tab = person)\n\nGet all unique person_id's from a database.\n\nArguments:\n\nconn - database connection using DBInterface\n\nKeyword Arguments:\n\ntab - the SQLTable representing the Person table; default person\n\nReturns\n\nids::Vector{Int64} - the list of persons\n\n\n\n\n\nGetDatabasePersonIDs(; tab = person)\n\nReturn SQL statement that gets all unique person_id's from a database.\n\nKeyword Arguments:\n\ntab - the SQLTable representing the Person table; default person\n\nReturns\n\nsql::String - Prepared SQL statement as a String\n\n\n\n\n\n","category":"function"},{"location":"api/#OMOPCDMCohortCreator.GetPatientState","page":"API","title":"OMOPCDMCohortCreator.GetPatientState","text":"GetPatientState(ids, conn; tab = location, join_tab = person)\n\nGiven a list of person IDs, find their home state.\n\nArguments:\n\nids - list of person_id's; each ID must be of subtype Integer\nconn - database connection using DBInterface\n\nKeyword Arguments:\n\ntab - the SQLTable representing the Location table; default location\njoin_tab - the SQLTable representing the Person table; default person\n\nReturns\n\ndf::DataFrame - a two column DataFrame comprised of columns: :person_id and :state\n\n\n\n\n\nGetPatientState(ids; tab = location, join_tab = person)\n\nReturn SQL statement where if given a list of person IDs, find their home state.\n\nArguments:\n\nids - list of person_id's; each ID must be of subtype Integer\nconn - database connection using DBInterface\n\nKeyword Arguments:\n\ntab - the SQLTable representing the Location table; default location\njoin_tab - the SQLTable representing the Person table; default person\n\nReturns\n\ndf::DataFrame - a two column DataFrame comprised of columns: :person_id and :state\n\n\n\n\n\n","category":"function"},{"location":"api/#OMOPCDMCohortCreator.GetPatientGender","page":"API","title":"OMOPCDMCohortCreator.GetPatientGender","text":"GetPatientGender(ids, conn; tab = person)\n\nGiven a list of person IDs, find their gender.\n\nArguments:\n\nids - list of person_id's; each ID must be of subtype Integer\nconn - database connection using DBInterface\n\nKeyword Arguments:\n\ntab - the SQLTable representing the Person table; default person\n\nReturns\n\ndf::DataFrame - a two column DataFrame comprised of columns: :person_id and :gender_concept_id\n\n\n\n\n\nGetPatientGender(ids; tab = person)\n\nReturn SQL statement that gets the gender_concept_id for a given list of person_id's\n\nArguments:\n\nids - list of person_id's; each ID must be of subtype Integer\n\nKeyword Arguments:\n\ntab - the SQLTable representing the Person table; default person\n\nReturns\n\ndf::DataFrame - a two column DataFrame comprised of columns: :person_id and :gender_concept_id\n\n\n\n\n\n","category":"function"},{"location":"api/#OMOPCDMCohortCreator.GetPatientRace","page":"API","title":"OMOPCDMCohortCreator.GetPatientRace","text":"GetPatientRace(ids, conn; tab = person)\n\nGiven a list of person IDs, find their race.\n\nArguments:\n\nids - list of person_id's; each ID must be of subtype Integer\nconn - database connection using DBInterface\n\nKeyword Arguments:\n\ntab - the SQLTable representing the Person table; default person\n\nReturns\n\ndf::DataFrame - a two column DataFrame comprised of columns: :person_id and :race_concept_id\n\n\n\n\n\nGetPatientRace(ids; tab = person)\n\nReturn SQL statement that gets the race_concept_id for a given list of person_id's\n\nArguments:\n\nids - list of person_id's; each ID must be of subtype Integer\n\nKeyword Arguments:\n\ntab - the SQLTable representing the Person table; default person\n\nReturns\n\ndf::DataFrame - a two column DataFrame comprised of columns: :person_id and :race_concept_id\n\n\n\n\n\n","category":"function"},{"location":"api/#OMOPCDMCohortCreator.GetPatientEthnicity","page":"API","title":"OMOPCDMCohortCreator.GetPatientEthnicity","text":"GetPatientEthnicity(ids, conn; tab = person)\n\nGiven a list of person IDs, find their ethnicity.\n\nArguments:\n\nids - list of person_id's; each ID must be of subtype Integer\nconn - database connection using DBInterface\n\nKeyword Arguments:\n\ntab - the SQLTable representing the Person table; default person\n\nReturns\n\ndf::DataFrame - a two column DataFrame comprised of columns: :person_id and :ethnicity_concept_id\n\n\n\n\n\nGetPatientEthnicity(ids, conn; tab = person)\n\nReturn SQL statement that gets the ethnicity_concept_id for a given list of person_id's\n\nArguments:\n\nids - list of person_id's; each ID must be of subtype Integer\n\nKeyword Arguments:\n\ntab - the SQLTable representing the Person table; default person\n\nReturns\n\ndf::DataFrame - a two column DataFrame comprised of columns: :person_id and :ethnicity_concept_id\n\n\n\n\n\n","category":"function"},{"location":"api/#OMOPCDMCohortCreator.GetPatientAgeGroup","page":"API","title":"OMOPCDMCohortCreator.GetPatientAgeGroup","text":"GetPatientAgeGroup(     ids, conn;     minuend = :now,     age_groupings = [         [0, 9],         [10, 19],         [20, 29],         [30, 39],         [40, 49],         [50, 59],         [60, 69],         [70, 79],         [80, 89],     ],     tab = person, )\n\nFinds all individuals in age groups as specified by age_groupings.\n\nArguments:\n\nids - list of person_id's; each ID must be of subtype Integer\nconn - database connection using DBInterface\n\nKeyword Arguments:\n\nage_groupings - a vector of age groups of the form [[10, 19], [20, 29],] denoting an age group of 10 - 19 and 20 - 29 respectively; age values must subtype of Integer\nminuend - the year that a patient's year_of_birth variable is subtracted from; default :now. There are two different options that can be set: \n:now - the year as of the day the code is executed given in UTC time\nany year provided by a user as long as it is an Integer (such as 2022, 1998, etc.)\ntab - the SQLTable representing the Person table; default person\n\nReturns\n\ndf::DataFrame - a two column DataFrame comprised of columns: :person_id and :age_group\n\nNote\n\nAge can be difficult to be calculated consistently. In this case, there are some assumptions made to ensure consistency: \n\nAccording to the OMOP CDM v5.4, only the variable year_of_birth is guaranteed for a given patient. This is one of three options used as the minuend in age calculations.\nThe subtrahend is based on what one chooses for the minuend key word argument.\n\nThe age is then calculated following what is selected based on 1 and 2. This flexibility is encoded to allow a user to choose how they want age groups calculated as well as clear up an ambiguity on how this is determined.\n\n\n\n\n\nGetPatientAgeGroup(     ids;     minuend = :now,     age_groupings = [         [0, 9],         [10, 19],         [20, 29],         [30, 39],         [40, 49],         [50, 59],         [60, 69],         [70, 79],         [80, 89],     ],     tab = person, )\n\nReturn SQL statement that assigns an age group to each patient in a given patient list.  Customized age groupings can be provided as a list.\n\nArguments:\n\nids - list of person_id's; each ID must be of subtype Integer\n\nKeyword Arguments:\n\nage_groupings - a vector of age groups of the form [[10, 19], [20, 29],] denoting an age group of 10 - 19 and 20 - 29 respectively; age values must subtype of Integer\nminuend - the year that a patient's year_of_birth variable is subtracted from; default :now. There are two different options that can be set: \n:now - the year as of the day the code is executed given in UTC time\nany year provided by a user as long as it is an Integer (such as 2022, 1998, etc.)\ntab - the SQLTable representing the Person table; default person\n\nReturns\n\ndf::DataFrame - a two column DataFrame comprised of columns: :person_id and :age_group\n\nNote\n\nAge can be difficult to be calculated consistently. In this case, there are some assumptions made to ensure consistency: \n\nAccording to the OMOP CDM v5.4, only the variable year_of_birth is guaranteed for a given patient. This is one of three options used as the minuend in age calculations.\nThe subtrahend is based on what one chooses for the minuend key word argument.\n\nThe age is then calculated following what is selected based on 1 and 2. This flexibility is encoded to allow a user to choose how they want age groups calculated as well as clear up an ambiguity on how this is determined.\n\n\n\n\n\n","category":"function"},{"location":"api/#OMOPCDMCohortCreator.GetPatientVisits","page":"API","title":"OMOPCDMCohortCreator.GetPatientVisits","text":"GetPatientVisits(ids, conn; tab = visit_occurrence)\n\nGiven a list of person IDs, find all their visits.\n\nArguments:\n\nids - list of person_id's; each ID must be of subtype Integer\nconn - database connection using DBInterface\n\nKeyword Arguments:\n\ntab - the SQLTable representing the Visit Occurrence table; default visit_occurrence\n\nReturns\n\ndf::DataFrame - a two column DataFrame comprised of columns: :person_id and :visit_occurrence_id\n\n\n\n\n\nGetPatientVisits(ids; tab = visit_occurrence)\n\nReturn SQL statement that returns all visit_occurrence_id for a given patient list\n\nArguments:\n\nids - list of person_id's; each ID must be of subtype Integer\n\nKeyword Arguments:\n\ntab - the SQLTable representing the Visit Occurrence table; default visit_occurrence\n\nReturns\n\ndf::DataFrame - a two column DataFrame comprised of columns: :person_id and :visit_occurrence_id\n\n\n\n\n\n","category":"function"},{"location":"api/#OMOPCDMCohortCreator.GetMostRecentConditions","page":"API","title":"OMOPCDMCohortCreator.GetMostRecentConditions","text":"GetMostRecentConditions(ids, conn; tab = condition_occurrence)\n\nGiven a list of person IDs, find their last recorded conditions.\n\nArguments:\n\nids - list of person_id's; each ID must be of subtype Integer\nconn - database connection using DBInterface\n\nKeyword Arguments:\n\ntab - the SQLTable representing the Condition Occurrence table; default condition_occurrence\n\nReturns\n\ndf::DataFrame - a two column DataFrame comprised of columns: :person_id and :condition_concept_id\n\n\n\n\n\nGetMostRecentConditions(ids; tab = condition_occurrence)\n\nProduces SQL statement that, given a list of person IDs, finds their last recorded conditions.\n\nArguments:\n\nids - list of person_id's; each ID must be of subtype Integer\n\nKeyword Arguments:\n\ntab - the SQLTable representing the Condition Occurrence table; default condition_occurrence\n\nReturns\n\ndf::DataFrame - a two column DataFrame comprised of columns: :person_id and :condition_concept_id\n\n\n\n\n\n","category":"function"},{"location":"api/#OMOPCDMCohortCreator.GetMostRecentVisit","page":"API","title":"OMOPCDMCohortCreator.GetMostRecentVisit","text":"GetMostRecentVisit(ids, conn; tab = visit_occurrence)\n\nGiven a list of person IDs, find their last recorded visit.\n\nArguments:\n\nids - list of person_id's; each ID must be of subtype Integer\nconn - database connection using DBInterface\n\nKeyword Arguments:\n\ntab - the SQLTable representing the Visit Occurrence table; default visit_occurrence\n\nReturns\n\ndf::DataFrame - a two column DataFrame comprised of columns: :person_id and :visit_occurrence_id\n\n\n\n\n\nGetMostRecentVisit(ids, conn; tab = visit_occurrence)\n\nProduces SQL statement that, given a list of person IDs, finds their last recorded visit.\n\nArguments:\n\nids - list of person_id's; each ID must be of subtype Integer\n\nKeyword Arguments:\n\ntab - the SQLTable representing the Visit Occurrence table; default visit_occurrence\n\nReturns\n\ndf::DataFrame - a two column DataFrame comprised of columns: :person_id and :visit_occurrence_id\n\n\n\n\n\n","category":"function"},{"location":"api/#OMOPCDMCohortCreator.GetVisitCondition","page":"API","title":"OMOPCDMCohortCreator.GetVisitCondition","text":"GetVisitCondition(visitids, conn; tab = visitoccurrence)\n\nGiven a list of visit IDs, find their corresponding conditions.\n\nArguments:\n\nvisit_ids - list of visit_id's; each ID must be of subtype Integer\nconn - database connection using DBInterface\n\nKeyword Arguments:\n\ntab - the SQLTable representing the Condition Occurrence table; default condition_occurrence\n\nReturns\n\ndf::DataFrame - a two column DataFrame comprised of columns: :visit_occurrence_id and :condition_concept_id\n\n\n\n\n\nGetVisitCondition(visitids; tab = visitoccurrence)\n\nProduces SQL statement that, given a list of visit_id's, finds the conditions diagnosed associated with that visit.\n\nArguments:\n\nvisit_ids - list of visit_id's; each ID must be of subtype Integer\n\nKeyword Arguments:\n\ntab - the SQLTable representing the Condition Occurrence table; default condition_occurrence\n\nReturns\n\ndf::DataFrame - a two column DataFrame comprised of columns: :visit_occurrence_id and :condition_concept_id\n\n\n\n\n\n","category":"function"},{"location":"api/#OMOPCDMCohortCreator.GetDatabaseYearRange","page":"API","title":"OMOPCDMCohortCreator.GetDatabaseYearRange","text":"GetDatabaseYearRange(conn; tab = observation_period)\n\nGet the years for which data is available from a database.\n\nArguments:\n\nconn - database connection using DBInterface\n\nKeyword Arguments:\n\ntab - the SQLTable representing the Observation Period table; default observation_period\n\nReturns\n\nyear_range::NamedTuple{(:first_year, :last_year), Tuple{Int64, Int64}} - a NamedTuple where first_year is the first year data from the database was available and last_year where the last year data from the database was available\n\n\n\n\n\nGetDatabaseYearRange(; tab = observation_period)\n\nReturn SQL to find the years for which data is available from a database.\n\nKeyword Arguments:\n\ntab - the SQLTable representing the Observation Period table; default observation_period\n\nReturns\n\nyear_range::NamedTuple{(:first_year, :last_year), Tuple{Int64, Int64}} - a NamedTuple where first_year is the first year data from the database was available and last_year where the last year data from the database was available\n\n\n\n\n\n","category":"function"},{"location":"api/#OMOPCDMCohortCreator.GetDrugExposureIDs","page":"API","title":"OMOPCDMCohortCreator.GetDrugExposureIDs","text":"GetDrugExposureIDs(ids, conn; tab = drug_exposure)\n\nGiven a list of person IDs, find their drug exposure.\n\nArguments:\n\nids - list of person_id's; each ID must be of subtype Integer\nconn - database connection using DBInterface\n\nKeyword Arguments:\n\ntab - the SQLTable representing the the drugexposure table; default `drugexposure`\n\nReturns\n\ndf::DataFrame - a two column DataFrame comprised of columns: :person_id and :drug_exposure_id\n\n\n\n\n\n","category":"function"},{"location":"api/#OMOPCDMCohortCreator.GetDrugConceptIDs","page":"API","title":"OMOPCDMCohortCreator.GetDrugConceptIDs","text":"GetDrugConcepts(drugexposureids; tab = drug_exposure)\n\nGiven a list of drug Exposure IDs, find their drugconceptid.\n\nArguments:\n\ndrug_exposure_ids - list of drug_exposure_id's; each ID must be of subtype Integer\nconn - database connection using DBInterface\n\nKeyword Arguments:\n\ntab - the SQLTable representing the drugexposure table; default `drugexposure`\n\nReturns\n\ndf::DataFrame - a two column DataFrame comprised of columns: :drug_exposure_id and :drug_concept_id\n\n\n\n\n\nGetDrugConcepts(drugexposureids; tab = drug_exposure)\n\nReturn SQL statement that gets the drug_concept_id for a given list of drug_exposure_id's\n\nArguments:\n\ndrug_exposure_ids - list of drug_exposure_id's; each ID must be of subtype Integer\n\nKeyword Arguments:\n\ntab - the SQLTable representing the drugexposure table; default `drugexposure`\n\nReturns\n\ndf::DataFrame - a two column DataFrame comprised of columns: :drug_exposure_id and :drug_concept_id\n\n\n\n\n\n","category":"function"},{"location":"api/#OMOPCDMCohortCreator.GetDrugAmounts","page":"API","title":"OMOPCDMCohortCreator.GetDrugAmounts","text":"GetDrugAmounts(drugconceptids, conn; tab = drug_strength)\n\nGiven a list of drugs concept IDs, find their amount.\n\nArguments:\n\ndrug_concept_ids - list of drug_concept_id's; each ID must be of subtype Integer\nconn - database connection using DBInterface\n\nKeyword Arguments:\n\ntab - the SQLTable representing the drugstrength table; default `drugstrength`\n\nReturns\n\ndf::DataFrame - a two column DataFrame comprised of columns: :drug_concept_id and :amount_value\n\n\n\n\n\nGetDrugAmounts(drugconceptids; tab = drug_strength)\n\nReturn SQL statement that gets the amount_value for a given list of drug_concept_id's\n\nArguments:\n\ndrug_concept_ids - list of drug_concept_id's; each ID must be of subtype Integer\n\nKeyword Arguments:\n\ntab - the SQLTable representing the drugstrength table; default `drugstrength`\n\nReturns\n\ndf::DataFrame - a two column DataFrame comprised of columns: :drug_concept_id and :amount_value\n\n\n\n\n\n","category":"function"},{"location":"api/#OMOPCDMCohortCreator.GetDatabaseCohorts","page":"API","title":"OMOPCDMCohortCreator.GetDatabaseCohorts","text":"GetDatabaseCohorts(conn; tab=cohort)\n\nGiven a DataFrame returns all unique cohortdefinitionid associated with a database.\n\n#Arguments:\n\nconn - database connection using DBInterface\n\nKeyword Arguments:\n\ntab - the SQLTable representing the Cohort table; default cohort\n\nReturns\n\ndf::DataFrame - a one column DataFrame comprised of columns: :cohort_definition_id\n\n\n\n\n\n","category":"function"},{"location":"api/#OMOPCDMCohortCreator.GetCohortSubjects","page":"API","title":"OMOPCDMCohortCreator.GetCohortSubjects","text":"GetCohortSubjects(cohort_ids, conn; tab = cohort)\n\nGiven a list of cohort IDs, find their corresponding subjects.\n\nArguments:\n\ncohort_ids - list of cohort_id's; each ID must be of subtype Float64\nconn - database connection using DBInterface\n\nKeyword Arguments:\n\ntab - the SQLTable representing the cohort table; default cohort\n\nReturns\n\ndf::DataFrame - a two column DataFrame comprised of columns: :cohort_definition_id and :subject_id\n\n\n\n\n\nGetCohortSubjects(cohort_ids; tab = cohort)\n\nProduces SQL statement that, given a list of cohort_id's, finds the subjects associated with that cohort.\n\nArguments:\n\ncohort_ids - list of cohort_id's; each ID must be of subtype Float64\n\nKeyword Arguments:\n\ntab - the SQLTable representing the cohort table; default cohort\n\nReturns\n\ndf::DataFrame - a two column DataFrame comprised of columns: :cohort_definition_id and :subject_id\n\n\n\n\n\n","category":"function"},{"location":"api/#OMOPCDMCohortCreator.GetCohortSubjectStartDate","page":"API","title":"OMOPCDMCohortCreator.GetCohortSubjectStartDate","text":"function GetCohortSubjectStartDate(cohortids, subjectids, conn; tab=cohort)\n\nGiven a single or list of cohort IDs and subject IDs, return their start dates.\n\n# Arguments:\n\n- `cohort_ids` - list of `cohort_id`'s; each ID must be of subtype `Float64`\n    \n- `subject_id` - list of `subject_id`'s; each ID must be of subtype `Float64`\n    \n- `conn` - database connection using DBInterface\n    \n# Keyword Arguments:\n    \n- `tab` - the `SQLTable` representing the `cohort` table; default `cohort`\n\nReturns\n\ndf::DataFrame - a three column DataFrame comprised of columns: :cohort_definition_id , :subject_id and :cohort_start_date\n\n\n\n\n\nfunction GetCohortSubjectStartDate(df:DataFrame, conn; tab = cohort)\n\nGiven a DataFrame with a :cohort_definition_id column and :subject_id column, return the DataFrame with an associated :cohort_start_date corresponding to a cohort's subject ID in the DataFrame\n\nMultiple dispatch that accepts all other arguments like in GetCohortSubjectStartDate(ids, conn; tab = cohort)\n\n\n\n\n\nfunction GetCohortSubjectStartDate(cohortids, subjectids; tab=cohort)\n\nGiven a list of cohort IDs and subject IDs return their start dates.\n\nArguments:\n\ncohort_ids - list of cohort_id's; each ID must be of subtype Float64\nsubject_id - list of subject_id's; each ID must be of subtype Float64\nconn - database connection using DBInterface\n\nKeyword Arguments:\n\ntab - the SQLTable representing the cohort table; default cohort\n\nReturns\n\ndf::DataFrame - a three column DataFrame comprised of columns: :cohort_definition_id , :subject_id and :cohort_start_date\n\n\n\n\n\n","category":"function"},{"location":"api/#OMOPCDMCohortCreator.GetCohortSubjectEndDate","page":"API","title":"OMOPCDMCohortCreator.GetCohortSubjectEndDate","text":"function GetCohortSubjectEndDate(cohortids, subjectids, conn; tab=cohort)\n\nGiven a list of cohort IDs and subject IDs return their end dates.\n\n# Arguments:\n\n- `cohort_ids` - list of `cohort_id`'s; each ID must be of subtype `Float64`\n    \n- `subject_id` - list of `subject_id`'s; each ID must be of subtype `Float64`\n    \n- `conn` - database connection using DBInterface\n    \n# Keyword Arguments:\n    \n- `tab` - the `SQLTable` representing the `cohort` table; default `cohort`\n\nReturns\n\ndf::DataFrame - a three column DataFrame comprised of columns: :cohort_definition_id , :subject_id and :cohort_end_date\n\n\n\n\n\nfunction GetCohortSubjectEndDate(df:DataFrame, conn; tab = cohort)\n\nGiven a DataFrame with a :cohort_definition_id column and :subject_id column, return the DataFrame with an associated :cohort_end_date corresponding to a given cohort_definition_id and subject_id in the DataFrame\n\nMultiple dispatch that accepts all other arguments like in GetCohortSubjectEndDate(ids, conn; tab = cohort)\n\n\n\n\n\nfunction GetCohortSubjectEndDate(cohortids; subjectids; tab=cohort)\n\nGiven a list of cohort IDs and subject IDs return their end date.\n\nArguments:\n\ncohort_ids - list of cohort_id's; each ID must be of subtype Float64\nsubject_id - list of subject_id's; each ID must be of subtype Float64\nconn - database connection using DBInterface\n\nKeyword Arguments:\n\ntab - the SQLTable representing the cohort table; default cohort\n\nReturns\n\ndf::DataFrame - a three column DataFrame comprised of columns: :cohort_definition_id , :subject_id and :cohort_end_date\n\n\n\n\n\n","category":"function"},{"location":"api/#OMOPCDMCohortCreator.GetVisitProcedure","page":"API","title":"OMOPCDMCohortCreator.GetVisitProcedure","text":"GetVisitProcedure(visitids, conn; tab = procedureoccurrence)\n\nGiven a list of visit IDs, find their corresponding procedures.\n\nArguments:\n\nvisit_ids - list of visit_id's; each ID must be of subtype Integer\nconn - database connection using DBInterface\n\nKeyword Arguments:\n\ntab - the SQLTable representing the Condition Occurrence table; default procedure_occurrence\n\nReturns\n\ndf::DataFrame - a two column DataFrame comprised of columns: :visit_occurrence_id and :procedure_concept_id\n\n\n\n\n\nGetVisitProcedure(visitids; tab = procedureoccurrence)\n\nProduces SQL statement that, given a list of visit_id's, finds the procedures associated with that visit.\n\nArguments:\n\nvisit_ids - list of visit_id's; each ID must be of subtype Integer\n\nKeyword Arguments:\n\ntab - the SQLTable representing the Procedure Occurrence table; default procedure_occurrence\n\nReturns\n\ndf::DataFrame - a two column DataFrame comprised of columns: :visit_occurrence_id and :procedure_concept_id\n\n\n\n\n\n","category":"function"},{"location":"api/#OMOPCDMCohortCreator.GetDrugExposureEndDate","page":"API","title":"OMOPCDMCohortCreator.GetDrugExposureEndDate","text":"function GetDrugExposureEndDate(drugexposureids; tab = drug_exposure)\n\nGiven a list of drugexposure IDs, find their corresponding drugexposureenddate ID.\n\nArguments:\n\ndrug_exposure_ids - list of drug_exposure_id's; each ID must be of subtype Float64\n\nKeyword Arguments:\n\ntab - the SQLTable representing the Drug Exposure table; default drug_exposure\n\nReturns\n\nSQL statement comprised of: :drug_exposure_id and :drug_exposure_end_date\n\n\n\n\n\n","category":"function"},{"location":"api/#OMOPCDMCohortCreator.GetDrugExposureStartDate","page":"API","title":"OMOPCDMCohortCreator.GetDrugExposureStartDate","text":"function GetDrugExposureStartDate(df:DataFrame, conn; tab = drug_exposure)\n\nGiven a DataFrame with a :drugexposureid column, return the DataFrame with an associated :drugexposurestartdate corresponding to a given drugexposure_id in the DataFrame.\n\nMultiple dispatch that accepts all other arguments like in GetDrugExposureStartDate(ids, conn; tab = drug_exposure)\n\n\n\n\n\nfunction GetDrugExposureStartDate(drugexposureids; tab = drug_exposure)\n\nGiven a list of drug_exposure IDs, find their corresponding drug_exposure_start_date ID.\n\n# Arguments:\n\n- `drug_exposure_ids` - list of `drug_exposure_id`'s; each ID must be of subtype `Float64`\n\n\n# Keyword Arguments:\n\n- `tab` - the `SQLTable` representing the Drug Exposure table; default `drug_exposure`\n\n# Returns\n\n- SQL statement comprised of: `:drug_exposure_id` and `:drug_exposure_start_date`\n\n\n\n\n\n","category":"function"},{"location":"api/#Filters","page":"API","title":"Filters","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"These functions accepts parameters to produce queries that look for specific subpopulations or information given specific patient identifier(s) (i.e. person_id). ","category":"page"},{"location":"api/","page":"API","title":"API","text":"VisitFilterPersonIDs\nConditionFilterPersonIDs\nRaceFilterPersonIDs\nGenderFilterPersonIDs\nStateFilterPersonIDs\nAgeGroupFilterPersonIDs","category":"page"},{"location":"api/#OMOPCDMCohortCreator.VisitFilterPersonIDs","page":"API","title":"OMOPCDMCohortCreator.VisitFilterPersonIDs","text":"VisitFilterPersonIDs(visitcodes, conn; tab = visitoccurrence)\n\nGiven a list of visit concept IDs, visit_codes return from the database patients matching at least one of the provided visit codes from the Visit Occurrence table.\n\nArguments:\n\nvisit_codes - a vector of visit_concept_id's; must be a subtype of Integer\nconn - database connection using DBInterface\n\nKeyword Arguments:\n\ntab - the SQLTable representing the Visit Occurrence table; default visit_occurrence\n\nReturns\n\nids::Vector{Int64} - the list of persons resulting from the filter\n\n\n\n\n\nVisitFilterPersonIDs(visitcodes; tab = visitoccurrence)\n\nGenerates a SQL statement that, given a list of visit concept IDs, visit_codes, return from the database patients matching at least one of the provided visit codes from the Visit Occurrence table.\n\nArguments:\n\nvisit_codes - a vector of visit_concept_id's; must be a subtype of Integer\n\nconn - database connection using DBInterface\n\nKeyword Arguments:\n\ntab - the SQLTable representing the Visit Occurrence table; default visit_occurrence\n\nReturns\n\nsql::String - the SQL representation that runs this filter\n\n\n\n\n\n","category":"function"},{"location":"api/#OMOPCDMCohortCreator.ConditionFilterPersonIDs","page":"API","title":"OMOPCDMCohortCreator.ConditionFilterPersonIDs","text":"ConditionFilterPersonIDs(conditioncodes, conn; tab = conditionoccurrence)\n\nGiven a list of condition concept IDs, condition_codes, return from the database individuals having at least one entry in the Condition Occurrence table matching at least one of the provided condition types.\n\nArguments:\n\ncondition_codes - a vector of condition_concept_id's; must be a subtype of Integer\nconn - database connection using DBInterface\n\nKeyword Arguments:\n\ntab - the SQLTable representing the Condition Occurrence table; default condition_occurrence\n\nReturns\n\nids::Vector{Int64} - the list of persons resulting from the filter\n\n\n\n\n\nConditionFilterPersonIDs(conditioncodes; tab = conditionoccurrence)\n\nGenerates a SQL statement that, given a list of condition concept IDs, condition_codes, return from the database individuals having at least one entry in the Condition Occurrence table matching at least one of the provided condition types.\n\nArguments:\n\ncondition_codes - a vector of condition_concept_id's; must be a subtype of Integer\n\nKeyword Arguments:\n\ntab - the SQLTable representing the Condition Occurrence table; default condition_occurrence\n\nReturns\n\nsql::String - the SQL representation that runs this filter\n\n\n\n\n\n","category":"function"},{"location":"api/#OMOPCDMCohortCreator.RaceFilterPersonIDs","page":"API","title":"OMOPCDMCohortCreator.RaceFilterPersonIDs","text":"RaceFilterPersonIDs(race_codes, conn; tab = person)\n\nGiven a list of condition concept IDs, race_codes, return from the database individuals having at least one entry in the Person table matching at least one of the provided race types.\n\nArguments:\n\nrace_codes - a vector of race_concept_id's; must be a subtype of Integer\nconn - database connection using DBInterface\n\nKeyword Arguments:\n\ntab - the SQLTable representing the Person table; default person\n\nReturns\n\nids::Vector{Int64} - the list of persons resulting from the filter\n\n\n\n\n\nRaceFilterPersonIDs(race_codes; tab = person)\n\nGenerates a SQL statement that, given a list of race_concept_id's, return from the database individuals having at least one entry in the Person table matching at least one of the provided race types.\n\nArguments:\n\nrace_codes - a vector of race_concept_id's; must be a subtype of Integer\n\nKeyword Arguments:\n\ntab - the SQLTable representing the Person table; default person\n\nReturns\n\nsql::String - the SQL representation that runs this filter\n\n\n\n\n\n","category":"function"},{"location":"api/#OMOPCDMCohortCreator.GenderFilterPersonIDs","page":"API","title":"OMOPCDMCohortCreator.GenderFilterPersonIDs","text":"GenderFilterPersonIDs(gendercodes, conn; tab = visitoccurrence)\n\nGiven a list of visit concept IDs, gender_codes return from the database individuals having at least one entry in the Person table matching at least one of the provided gender types.\n\nArguments:\n\nvisit_codes - a vector of gender_concept_id's; must be a subtype of Integer\nconn - database connection using DBInterface\n\nKeyword Arguments:\n\ntab - the SQLTable representing the Person table; default person\n\nReturns\n\nids::Vector{Int64} - the list of persons resulting from the filter\n\n\n\n\n\nGenderFilterPersonIDs(gendercodes; tab = visitoccurrence)\n\nGenerates a SQL statement that, given a list of visit concept IDs, gender_codes return from the database individuals having at least one entry in the Person table matching at least one of the provided gender types.\n\nArguments:\n\nvisit_codes - a vector of gender_concept_id's; must be a subtype of Integer\n\nKeyword Arguments:\n\ntab - the SQLTable representing the Person table; default person\n\nReturns\n\nsql::String - the SQL representation that runs this filter\n\n\n\n\n\n","category":"function"},{"location":"api/#OMOPCDMCohortCreator.StateFilterPersonIDs","page":"API","title":"OMOPCDMCohortCreator.StateFilterPersonIDs","text":"StateFilterPersonIDs(states, conn; tab = location, join_tab = person)\n\nGiven a list of states, states, return from the database individuals found in the provided state list.\n\nArguments:\n\nstates - a vector of state abbreviations; must be a subtype of AbstractString\nconn - database connection using DBInterface\n\nKeyword Arguments:\n\ntab - the SQLTable representing the Location table; default location\njoin_tab - the SQLTable representing the Person table; default person\n\nReturns\n\nids::Vector{Int64} - the list of persons resulting from the filter\n\n\n\n\n\nStateFilterPersonIDs(states; tab = location, join_tab = person)\n\nGenerates a SQL statement that, given a list of states, states, return from the database individuals found in the provided state list.\n\nArguments:\n\nstates - a vector of state abbreviations; must be a subtype of AbstractString\n\nKeyword Arguments:\n\ntab - the SQLTable representing the Location table; default location\njoin_tab - the SQLTable representing the Person table; default person\n\nReturns\n\nsql::String - the SQL representation that runs this filter\n\n\n\n\n\n","category":"function"},{"location":"api/#Generators","page":"API","title":"Generators","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"The generator functions are to set generate initial connections to an OMOP CDM database or to finalize resulting data from queries into various outputs. ","category":"page"},{"location":"api/","page":"API","title":"API","text":"GenerateDatabaseDetails\nGenerateGroupCounts\nGenerateTables","category":"page"},{"location":"api/#OMOPCDMCohortCreator.GenerateDatabaseDetails","page":"API","title":"OMOPCDMCohortCreator.GenerateDatabaseDetails","text":"GenerateDatabaseDetails(dialect::Symbol, schema::String)\n\nGenerates the dialect and schema details for accessing a given OMOP CDM database.\n\nArguments:\n\ndialect::Symbol - the dialect used for SQL queries (to see what is dialects are available, see here: https://mechanicalrabbit.github.io/FunSQL.jl/stable/reference/#FunSQL.SQLDialect)\nschema::String - the name of the database schema being used.\n\n\n\n\n\n","category":"function"},{"location":"api/#OMOPCDMCohortCreator.GenerateGroupCounts","page":"API","title":"OMOPCDMCohortCreator.GenerateGroupCounts","text":"GenerateGroupCounts(data::DataFrame)\n\nGiven data in a DataFrame, get group counts based on each feature found in the DataFrame and removes person_id for privacy aggregation purposes.\n\nArguments:\n\ndata::DataFrame - a DataFrame that must have at least a person_id column\n\nReturns:\n\ndf::DataFrame - a DataFrame that contains the group counts based on each feature found in data with the person_id field removed for privacy\n\n\n\n\n\n","category":"function"},{"location":"api/#OMOPCDMCohortCreator.GenerateTables","page":"API","title":"OMOPCDMCohortCreator.GenerateTables","text":"GenerateTables(conn; inplace = true, exported = false)\n\nGenerates Julia representations of all tables found in a given OMOP CDM database.\n\nArguments:\n\ndialect::Symbol - the dialect used for SQL queries (to see what is dialects are available, see here: https://mechanicalrabbit.github.io/FunSQL.jl/stable/reference/#FunSQL.SQLDialect)\nschema::String - the name of the database schema being used.\n\n\n\n\n\n","category":"function"},{"location":"api/#Executors","page":"API","title":"Executors","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"These functions perform quality assurance checks on data extracts genereated from OMOPCDMCohortCreator queries.","category":"page"},{"location":"api/","page":"API","title":"API","text":"ExecuteAudit","category":"page"},{"location":"api/#OMOPCDMCohortCreator.ExecuteAudit","page":"API","title":"OMOPCDMCohortCreator.ExecuteAudit","text":"ExecuteAudit(data::DataFrame; hitech = true)\n\nFunction that executes an audit on a dataframe that must contain a count column to ensure compliance with auditing and privacy preserving best practices\n\nArguments:\n\ndata::DataFrame - the data to audit that must be in a DataFrame and contain a column called count\n\nKeyword Arguments:\n\nhitech::Bool - a boolean that enforces HITECH standards for privacy preserving methods.\ntarget_column::Symbol - the name of the column to target for auditing (default set to :count).\n\nReturns\n\ndf - a DataFrame that is appropriately audited per a given standard\n\n\n\n\n\n","category":"function"},{"location":"tutorials/#Tutorials","page":"Tutorials","title":"Tutorials","text":"","category":"section"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"Pages = [\"tutorials.md\"]","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"These tutorials are designed to equip new users with how to get started with OMOPCDMCohortCreator:","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"Beginner Tutorial - a step by step guide on using OMOPCDMCohortCreator to run a mini characterization study with minimal Julia knowledge required! Difficulty: Easy\nUsing OMOPCDMCohortCreator with R - a guide on how to use OMOPCDMCohortCreator within R to run a mini characterization study. Difficulty: Medium","category":"page"},{"location":"contributing/#Contributing-to-OMOPCDMCohortCreator","page":"Contributing","title":"Contributing to OMOPCDMCohortCreator 😁","text":"","category":"section"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"OMOPCDMCohortCreator is currently under heavy development as we push to a primary release version.  We follow a workflow pattern that is directly inspired by the development workflow guide found in Plots.jl. The general workflow we expect contributors to adhere to is as follows:","category":"page"},{"location":"contributing/#.-Create-an-Issue-about-the-Problem","page":"Contributing","title":"1. Create an Issue about the Problem 📝","text":"","category":"section"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"If you want to add functionality or to work on a bug you found, open an issue first. That'll save you from doing work that we may not support for OMOPCDMCohortCreator.","category":"page"},{"location":"contributing/#.-Fork-the-repo-to-your-account","page":"Contributing","title":"2. Fork the repo to your account 🍴","text":"","category":"section"},{"location":"contributing/#.-Create-a-branch-based-on-what-you-are-developing","page":"Contributing","title":"3. Create a branch based on what you are developing 🌳","text":"","category":"section"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"Before making a branch, make sure to check that you are even with master via the following commands within your fork:","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"git fetch origin\ngit checkout master\ngit merge --ff-only origin/master","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"The --ff-only flag will \"fast forward\" to newer commits. It will not create new merge commits.","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"Then, go ahead and create a branch that you could edit with the changes you want to see. This is done by going into the root and typing: git branch -b [name of your branch]","category":"page"},{"location":"contributing/#.-Test,-code,-and-commit","page":"Contributing","title":"4. Test, code, and commit ✏️","text":"","category":"section"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"Once you have a fork, it is useful to make sure the fork was successful. To verify that everything is operational, let's test it. The following procedure is as follows:","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"Go into the root of your fork:","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"cd OMOPCDMCohortCreator","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"Open your Julia REPL and type the following within the repo:","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"julia> ]\n(@v###) pkg> activate .\n(@v###) pkg> test","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"This might take some time, but if the installation on your computer is successful, it should say all tests passed.","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"After making the changes you wanted to make, run the tests again to make sure you did not introduce any breaking changes. If everything passed, we can continue on to the next step. If not, it is the responsibility of the contributor to resolve any conflicts or failing tests. Don't worry! We're happy to help you resolve errors. 😄 If you are stuck, go ahead and continue with this tutorial.","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"The way we do this is in three steps:","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"Add the files you have added or changed via git add \nAfter adding the files, we need to say what you did to the files (i.e. commit the files). This can be accomplished thusly: git commit -m \"your message\" \nFinally, let's push these changes to GitHub using git push --set-upstream origin [name of the branch you made]","category":"page"},{"location":"contributing/#.-Submitting-your-changes-to-the-main-project","page":"Contributing","title":"5. Submitting your changes to the main project ✅","text":"","category":"section"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"Almost done! Go to your fork and there should be a section that asks you to make a pull request (PR) from your branch. This allows the maintainers of OMOPCDMCohortCreator to see if they can add your changes to the main project. If not, you can click the \"New pull request\" button.","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"Make sure the \"base\" branch is OMOPCDMCohortCreator dev and the \"compare\" branch is the branch on your fork.  To your PR, add an informative title and description, and link your PR to relevant issues or discussions.  Finally, click \"Create pull request\". ","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"You may get some questions about it, and possibly suggestions of how to make it ready to go into the main project.  If you had test errors or problems, we are happy to help you.  Then, if all goes according to plan, it gets merged... Thanks for the contribution!! 🎉 🎉 🎉","category":"page"},{"location":"contributing/#Note-on-Adding-Dependencies","page":"Contributing","title":"Note on Adding Dependencies 📚","text":"","category":"section"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"As a rule, we try to avoid having too many dependencies. Therefore, we request that if you have a PR that adds a new dependency, please have opened an issue previously.","category":"page"},{"location":"contributing/#Adding-Core-Dependencies","page":"Contributing","title":"Adding Core Dependencies 📒","text":"","category":"section"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"If you are working on introducing a new core dependency, make sure to add that dependency to the main Project.toml for OMOPCDMCohortCreator. To do this, follow these steps:","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"Enter the root of the OMOPCDMCohortCreator directory ","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"cd /path/to/OMOPCDMCohortCreator.jl","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"Activate the OMOPCDMCohortCreator environment and add the dependency:","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"julia> ]\n(@v###) pkg> activate .\n(OMOPCDMCohortCreator) pkg> add [NAME OF DEPENDENCY]","category":"page"},{"location":"contributing/#Adding-Test-Dependencies","page":"Contributing","title":"Adding Test Dependencies 📋","text":"","category":"section"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"If you are  introducing a new test dependency, make sure to add that dependency to the Project.toml located in the OMOPCDMCohortCreator test directory. To do this, follow these steps:","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"Enter the test directory inside of the OMOPCDMCohortCreator directory ","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"cd /path/to/OMOPCDMCohortCreator.jl/test/","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"Activate the OMOPCDMCohortCreator test environment and add the dependency:","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"julia> ]\n(@v###) pkg> activate .\n(test) pkg> add [NAME OF DEPENDENCY]","category":"page"},{"location":"tutorials/beginner_tutorial/#Beginner-Tutorial","page":"Beginner Tutorial 🐣","title":"Beginner Tutorial 🐣","text":"","category":"section"},{"location":"tutorials/beginner_tutorial/","page":"Beginner Tutorial 🐣","title":"Beginner Tutorial 🐣","text":"Pages = [\"beginner_tutorial.md\"]","category":"page"},{"location":"tutorials/beginner_tutorial/","page":"Beginner Tutorial 🐣","title":"Beginner Tutorial 🐣","text":"This tutorial presents a step by step guide on using OMOPCDMCohortCreator to run a mini characterization study! You will learn the basics of OMOPCDMCohortCreator and how to use it with fake data that you could then apply to your real data sets. Basic knowledge of Julia (such as installing packages into environments and working with the Julia REPL and Julia files) is necessary; you can learn all that here.","category":"page"},{"location":"tutorials/beginner_tutorial/#Environment-Set-Up","page":"Beginner Tutorial 🐣","title":"Environment Set-Up 📝","text":"","category":"section"},{"location":"tutorials/beginner_tutorial/","page":"Beginner Tutorial 🐣","title":"Beginner Tutorial 🐣","text":"For this tutorial, you will need to activate an environment; to get into package mode within your Julia REPL, write ]:","category":"page"},{"location":"tutorials/beginner_tutorial/","page":"Beginner Tutorial 🐣","title":"Beginner Tutorial 🐣","text":"pkg> activate TUTORIAL","category":"page"},{"location":"tutorials/beginner_tutorial/#Packages","page":"Beginner Tutorial 🐣","title":"Packages","text":"","category":"section"},{"location":"tutorials/beginner_tutorial/","page":"Beginner Tutorial 🐣","title":"Beginner Tutorial 🐣","text":"You will need the following packages for this tutorial which you can install in package mode:","category":"page"},{"location":"tutorials/beginner_tutorial/","page":"Beginner Tutorial 🐣","title":"Beginner Tutorial 🐣","text":"TUTORIAL> add OMOPCDMCohortCreator\nTUTORIAL> add SQLite\nTUTORIAL> add DataFrames\nTURORIAL> add HealthSampleData","category":"page"},{"location":"tutorials/beginner_tutorial/","page":"Beginner Tutorial 🐣","title":"Beginner Tutorial 🐣","text":"To learn more about these packages, see the Appendix.","category":"page"},{"location":"tutorials/beginner_tutorial/#Data","page":"Beginner Tutorial 🐣","title":"Data","text":"","category":"section"},{"location":"tutorials/beginner_tutorial/","page":"Beginner Tutorial 🐣","title":"Beginner Tutorial 🐣","text":"For this tutorial, we will work with data from Eunomia that is stored in a SQLite format. To install the data on your machine, execute the following code block and follow the prompts - you will need a stable internet connection for the download to complete: ","category":"page"},{"location":"tutorials/beginner_tutorial/","page":"Beginner Tutorial 🐣","title":"Beginner Tutorial 🐣","text":"import HealthSampleData: Eunomia\n\neunomia = Eunomia()","category":"page"},{"location":"tutorials/beginner_tutorial/#Connecting-to-the-Eunomia-Database","page":"Beginner Tutorial 🐣","title":"Connecting to the Eunomia Database 💾","text":"","category":"section"},{"location":"tutorials/beginner_tutorial/","page":"Beginner Tutorial 🐣","title":"Beginner Tutorial 🐣","text":"After you have finished your set up in the Julia, we need to establish a connection to the Eunomia SQLite database that we will use for the rest of the tutorial: ","category":"page"},{"location":"tutorials/beginner_tutorial/","page":"Beginner Tutorial 🐣","title":"Beginner Tutorial 🐣","text":"import SQLite: DB\n\nconn = DB(eunomia)","category":"page"},{"location":"tutorials/beginner_tutorial/","page":"Beginner Tutorial 🐣","title":"Beginner Tutorial 🐣","text":"With Eunomia, the database's schema is simply called \"main\". We will use this to generate database connection details that will inform OMOPCDMCohortCreator about the type of queries we will write (i.e. SQLite) and the name of the database's schema. For this step, we will use OMOPCDMCohortCreator:","category":"page"},{"location":"tutorials/beginner_tutorial/","page":"Beginner Tutorial 🐣","title":"Beginner Tutorial 🐣","text":"import OMOPCDMCohortCreator as occ\n\nocc.GenerateDatabaseDetails(\n    :sqlite,\n    \"main\"\n)","category":"page"},{"location":"tutorials/beginner_tutorial/","page":"Beginner Tutorial 🐣","title":"Beginner Tutorial 🐣","text":"Finally, we will generate internal representations of each table found within Eunomia for OMOPCDMCohortCreator to use:","category":"page"},{"location":"tutorials/beginner_tutorial/","page":"Beginner Tutorial 🐣","title":"Beginner Tutorial 🐣","text":"occ.GenerateTables(conn)","category":"page"},{"location":"tutorials/beginner_tutorial/","page":"Beginner Tutorial 🐣","title":"Beginner Tutorial 🐣","text":"As a check to make sure everything was correctly installed and works properly, the following block should work and return a list of all person ids in this data:","category":"page"},{"location":"tutorials/beginner_tutorial/","page":"Beginner Tutorial 🐣","title":"Beginner Tutorial 🐣","text":"occ.GetDatabasePersonIDs(conn)","category":"page"},{"location":"tutorials/beginner_tutorial/#Characterizing-Patients-Who-Have-Had-Strep-Throat","page":"Beginner Tutorial 🐣","title":"Characterizing Patients Who Have Had Strep Throat 🤒","text":"","category":"section"},{"location":"tutorials/beginner_tutorial/#Background","page":"Beginner Tutorial 🐣","title":"Background","text":"","category":"section"},{"location":"tutorials/beginner_tutorial/","page":"Beginner Tutorial 🐣","title":"Beginner Tutorial 🐣","text":"As all the tools are working properly, let's do what is called a characterization study - a study that characterizes a group of patients with a certain condition (or conditions) across various attributes like race, age, and combinations thereof. We are going to do miniature version of such a study looking at patients with strep throat. For this, we will use the condition_concept_id: 28060 - this will be needed for you to get correct results.","category":"page"},{"location":"tutorials/beginner_tutorial/","page":"Beginner Tutorial 🐣","title":"Beginner Tutorial 🐣","text":"NOTE: As we go through this example, do not immediately jump to the code block required but try to use the API to come up with solutions as there may be more than one answer.","category":"page"},{"location":"tutorials/beginner_tutorial/#Task:-Find-All-Patients-with-Strep-Throat","page":"Beginner Tutorial 🐣","title":"Task: Find All Patients with Strep Throat","text":"","category":"section"},{"location":"tutorials/beginner_tutorial/","page":"Beginner Tutorial 🐣","title":"Beginner Tutorial 🐣","text":"Using the API, find all patients with strep throat.","category":"page"},{"location":"tutorials/beginner_tutorial/","page":"Beginner Tutorial 🐣","title":"Beginner Tutorial 🐣","text":"Suggested solution:","category":"page"},{"location":"tutorials/beginner_tutorial/","page":"Beginner Tutorial 🐣","title":"Beginner Tutorial 🐣","text":"strep_patients = occ.ConditionFilterPersonIDs(28060, conn)","category":"page"},{"location":"tutorials/beginner_tutorial/","page":"Beginner Tutorial 🐣","title":"Beginner Tutorial 🐣","text":"Note: This function can accept more than one conditionconceptid.  Example:","category":"page"},{"location":"tutorials/beginner_tutorial/","page":"Beginner Tutorial 🐣","title":"Beginner Tutorial 🐣","text":"concept_ids = [28060, 433037, 372654, 443599, 436519]\npatients = occ.ConditionFilterPersonIDs(concept_ids, conn)","category":"page"},{"location":"tutorials/beginner_tutorial/#Task:-Find-the-Race-of-Patients-with-Strep-Throat","page":"Beginner Tutorial 🐣","title":"Task: Find the Race of Patients with Strep Throat","text":"","category":"section"},{"location":"tutorials/beginner_tutorial/","page":"Beginner Tutorial 🐣","title":"Beginner Tutorial 🐣","text":"For the patients who have strep throat diagnoses, find their race.","category":"page"},{"location":"tutorials/beginner_tutorial/","page":"Beginner Tutorial 🐣","title":"Beginner Tutorial 🐣","text":"Suggested solution:","category":"page"},{"location":"tutorials/beginner_tutorial/","page":"Beginner Tutorial 🐣","title":"Beginner Tutorial 🐣","text":"strep_patients_race = occ.GetPatientRace(strep_patients.person_id, conn)","category":"page"},{"location":"tutorials/beginner_tutorial/#Task:-Find-the-Gender-of-Patients-with-Strep-Throat","page":"Beginner Tutorial 🐣","title":"Task: Find the Gender of Patients with Strep Throat","text":"","category":"section"},{"location":"tutorials/beginner_tutorial/","page":"Beginner Tutorial 🐣","title":"Beginner Tutorial 🐣","text":"For the patients who have strep throat diagnoses, find their gender.","category":"page"},{"location":"tutorials/beginner_tutorial/","page":"Beginner Tutorial 🐣","title":"Beginner Tutorial 🐣","text":"Suggested solution:","category":"page"},{"location":"tutorials/beginner_tutorial/","page":"Beginner Tutorial 🐣","title":"Beginner Tutorial 🐣","text":"strep_patients_gender = occ.GetPatientGender(strep_patients.person_id, conn)","category":"page"},{"location":"tutorials/beginner_tutorial/#Task:-Create-Age-Groupings-of-Patients-with-Strep-Throat","page":"Beginner Tutorial 🐣","title":"Task: Create Age Groupings of Patients with Strep Throat","text":"","category":"section"},{"location":"tutorials/beginner_tutorial/","page":"Beginner Tutorial 🐣","title":"Beginner Tutorial 🐣","text":"For this task, for every single person who has a strep throat diagnosis, assign them an age group. The age groupings must follow 5 year intervals when assigned to a person up to 100 years of age (e.g. 0 4 5 9  95 100).","category":"page"},{"location":"tutorials/beginner_tutorial/","page":"Beginner Tutorial 🐣","title":"Beginner Tutorial 🐣","text":"Suggested solution:","category":"page"},{"location":"tutorials/beginner_tutorial/","page":"Beginner Tutorial 🐣","title":"Beginner Tutorial 🐣","text":"age_groups = [\n\t[0, 4],\n\t[5, 9],\n\t[10, 14],\n\t[15, 19],\n\t[20, 24],\n\t[25, 29],\n\t[30, 34],\n\t[35, 39],\n\t[40, 44],\n\t[45, 49],\n\t[50, 54],\n\t[55, 59],\n\t[60, 64],\n\t[65, 69],\n\t[70, 74],\n\t[75, 79],\n\t[80, 84],\n\t[85, 89],\n\t[90, 94],\n\t[95, 99]\n]\nstrep_patients_age_group = occ.GetPatientAgeGroup(strep_patients, conn; age_groupings = age_groups)","category":"page"},{"location":"tutorials/beginner_tutorial/#Task:-Characterize-Each-Person-by-Gender,-Race,-and-Age-Group","page":"Beginner Tutorial 🐣","title":"Task: Characterize Each Person by Gender, Race, and Age Group","text":"","category":"section"},{"location":"tutorials/beginner_tutorial/","page":"Beginner Tutorial 🐣","title":"Beginner Tutorial 🐣","text":"With the previous tasks, we now know patients' gender, race, and age group. Using this information, combine these features to create a final table where each patient's person_id, gender, race, and age group is found in a given row. Hint: The DataFrames.jl documentation section on joins will be of strong use here.","category":"page"},{"location":"tutorials/beginner_tutorial/","page":"Beginner Tutorial 🐣","title":"Beginner Tutorial 🐣","text":"Suggested solution:","category":"page"},{"location":"tutorials/beginner_tutorial/","page":"Beginner Tutorial 🐣","title":"Beginner Tutorial 🐣","text":"import DataFrames as DF\n\nstrep_patients_characterized = DF.outerjoin(strep_patients_race, strep_patients_gender, strep_patients_age_group; on = :person_id, matchmissing = :equal)","category":"page"},{"location":"tutorials/beginner_tutorial/#Task:-Create-Patient-Groupings","page":"Beginner Tutorial 🐣","title":"Task: Create Patient Groupings","text":"","category":"section"},{"location":"tutorials/beginner_tutorial/","page":"Beginner Tutorial 🐣","title":"Beginner Tutorial 🐣","text":"Often with characterization style studies, it is extremely important to aggregate patient populations. Why? To protect the anonymity of patients with perhaps severely sensitive conditions (e.g. mental illnesses, sexually transmitted diseases, etc.) from possible repercussions from accidental disclosure of this patient information.","category":"page"},{"location":"tutorials/beginner_tutorial/","page":"Beginner Tutorial 🐣","title":"Beginner Tutorial 🐣","text":"For this task, add to the table you created in the previous task a new column called counts and remove the person_id column. The counts column should represent the total number of patients belonging to a group's gender, race, and age group. Here is an example on how to calculate counts: if there are 5 rows in your table that have patients who are between the ages of 20 - 24, are African American, and are female, the value for that age, race, and gender group is 5. The 5 rows would then collapse into 1 row as unique patient identifiers (the person_id column) would be removed. Hint: removing the person_id column first may make things easier; also, look at the DataFrames.jl documentation on the Split-Apply-Combine approach to generate the counts column.","category":"page"},{"location":"tutorials/beginner_tutorial/","page":"Beginner Tutorial 🐣","title":"Beginner Tutorial 🐣","text":"Suggested solution:","category":"page"},{"location":"tutorials/beginner_tutorial/","page":"Beginner Tutorial 🐣","title":"Beginner Tutorial 🐣","text":"strep_patients_characterized = strep_patients_characterized[:, DF.Not(:person_id)]\nstrep_patient_groups = DF.groupby(strep_patients_characterized, [:race_concept_id, :gender_concept_id, :age_group])\nstrep_patient_groups = DF.combine(strep_patient_groups, DF.nrow => :counts)","category":"page"},{"location":"tutorials/beginner_tutorial/#Task:-Execute-Safety-Audit","page":"Beginner Tutorial 🐣","title":"Task: Execute Safety Audit","text":"","category":"section"},{"location":"tutorials/beginner_tutorial/","page":"Beginner Tutorial 🐣","title":"Beginner Tutorial 🐣","text":"To ensure the safety of the patients in this table, we can execute an audit. One such auditing standard are those put forth by \"HITECH\" which, amongst other things, requires researchers to filter out from a table patient counts  11 in subpopulation groups – the kind of groups we created! We can apply that as follows:","category":"page"},{"location":"tutorials/beginner_tutorial/","page":"Beginner Tutorial 🐣","title":"Beginner Tutorial 🐣","text":"audited_strep_patient_groups = occ.ExecuteAudit(strep_patient_groups; hitech = true)","category":"page"},{"location":"tutorials/beginner_tutorial/#Conclusion","page":"Beginner Tutorial 🐣","title":"Conclusion 🎉","text":"","category":"section"},{"location":"tutorials/beginner_tutorial/","page":"Beginner Tutorial 🐣","title":"Beginner Tutorial 🐣","text":"This mini characterization study that we just conducted on this dataset opens up a whole new avenue for a researcher to pursue. For example, we could now calculate prevalence rates across different patient characteristics or compare and contrast multiple conditions at once. It should also be apparent that the API is set up in a very particular way: it is functional meaning that each function does one thing only. This gives a lot of flexibility to a user to build together study incrementally using OMOPCDMCohortCreator. Congratulations on finishing this tutorial and if there are any issues you encountered, feel free to open an issue here!","category":"page"},{"location":"tutorials/beginner_tutorial/#Appendix","page":"Beginner Tutorial 🐣","title":"Appendix 🕵️","text":"","category":"section"},{"location":"tutorials/beginner_tutorial/#Packages-Used-in-Analysis","page":"Beginner Tutorial 🐣","title":"Packages Used in Analysis","text":"","category":"section"},{"location":"tutorials/beginner_tutorial/","page":"Beginner Tutorial 🐣","title":"Beginner Tutorial 🐣","text":"Package descriptions:","category":"page"},{"location":"tutorials/beginner_tutorial/","page":"Beginner Tutorial 🐣","title":"Beginner Tutorial 🐣","text":"DataFrames - Julia's dataframe handler for easily manipulating data\nOMOPCDMCohortCreator - Create cohorts from databases utilizing the OMOP CDM\nHealthSampleData - Sample health data for a variety of health formats and use cases\nSQLite - A Julia interface to the SQLite library","category":"page"},{"location":"tutorials/r_tutorial/#Using-OMOPCDMCohortCreator-with-R","page":"Using OMOPCDMCohortCreator with R 🏴‍☠️","title":"Using OMOPCDMCohortCreator with R 🏴‍☠️","text":"","category":"section"},{"location":"tutorials/r_tutorial/","page":"Using OMOPCDMCohortCreator with R 🏴‍☠️","title":"Using OMOPCDMCohortCreator with R 🏴‍☠️","text":"Pages = [\"r_tutorial.md\"]","category":"page"},{"location":"tutorials/r_tutorial/","page":"Using OMOPCDMCohortCreator with R 🏴‍☠️","title":"Using OMOPCDMCohortCreator with R 🏴‍☠️","text":"This tutorial builds on the Beginner Tutorial in creating a characterization study but instead of using Julia, we will use R! This assumes the user has familiarity with R but familiarity with Julia is not required. By the end of this tutorial, you will learn how to use OMOPCDMCohortCreator directly within R without having to ever touch Julia.","category":"page"},{"location":"tutorials/r_tutorial/#Analysis-Set-up","page":"Using OMOPCDMCohortCreator with R 🏴‍☠️","title":"Analysis Set-up 📝","text":"","category":"section"},{"location":"tutorials/r_tutorial/#R-and-Julia-Installation","page":"Using OMOPCDMCohortCreator with R 🏴‍☠️","title":"R and Julia Installation","text":"","category":"section"},{"location":"tutorials/r_tutorial/","page":"Using OMOPCDMCohortCreator with R 🏴‍☠️","title":"Using OMOPCDMCohortCreator with R 🏴‍☠️","text":"You will need to have R and Julia installed onto your computer. Here are the minimum required versions needed:","category":"page"},{"location":"tutorials/r_tutorial/","page":"Using OMOPCDMCohortCreator with R 🏴‍☠️","title":"Using OMOPCDMCohortCreator with R 🏴‍☠️","text":"R version must be greater than or equal to version 32.\nJulia version must be greater than or equal to version 17.","category":"page"},{"location":"tutorials/r_tutorial/","page":"Using OMOPCDMCohortCreator with R 🏴‍☠️","title":"Using OMOPCDMCohortCreator with R 🏴‍☠️","text":"Furthermore, the Julia executable must be available from the system PATH or you can set the JULIA_BINDIR R environment variable to where the Julia bin directory is on your computer like this:","category":"page"},{"location":"tutorials/r_tutorial/","page":"Using OMOPCDMCohortCreator with R 🏴‍☠️","title":"Using OMOPCDMCohortCreator with R 🏴‍☠️","text":"# For Windows\nSys.setenv(JULIA_BINDIR = \"C:/Users/user/AppData/Local/Programs/Julia-1.7.1/bin\")\n\n# For Linux or OSX\nSys.setenv(JULIA_BINDIR = \"~/path/to/Julia-1.7.1/bin\")","category":"page"},{"location":"tutorials/r_tutorial/#Packages","page":"Using OMOPCDMCohortCreator with R 🏴‍☠️","title":"Packages","text":"","category":"section"},{"location":"tutorials/r_tutorial/#R-Packages","page":"Using OMOPCDMCohortCreator with R 🏴‍☠️","title":"R Packages","text":"","category":"section"},{"location":"tutorials/r_tutorial/","page":"Using OMOPCDMCohortCreator with R 🏴‍☠️","title":"Using OMOPCDMCohortCreator with R 🏴‍☠️","text":"You will need the following packages for this tutorial which you can install with install.packages:","category":"page"},{"location":"tutorials/r_tutorial/","page":"Using OMOPCDMCohortCreator with R 🏴‍☠️","title":"Using OMOPCDMCohortCreator with R 🏴‍☠️","text":"dplyr\nJuliaConnectoR\ntibble","category":"page"},{"location":"tutorials/r_tutorial/","page":"Using OMOPCDMCohortCreator with R 🏴‍☠️","title":"Using OMOPCDMCohortCreator with R 🏴‍☠️","text":"To read more on these packages and what they do, see the appendix for details.","category":"page"},{"location":"tutorials/r_tutorial/#Julia-Packages","page":"Using OMOPCDMCohortCreator with R 🏴‍☠️","title":"Julia Packages","text":"","category":"section"},{"location":"tutorials/r_tutorial/","page":"Using OMOPCDMCohortCreator with R 🏴‍☠️","title":"Using OMOPCDMCohortCreator with R 🏴‍☠️","text":"You will need the following packages for this tutorial:","category":"page"},{"location":"tutorials/r_tutorial/","page":"Using OMOPCDMCohortCreator with R 🏴‍☠️","title":"Using OMOPCDMCohortCreator with R 🏴‍☠️","text":"HealthSampleData\nOMOPCDMCohortCreator\nSQLite","category":"page"},{"location":"tutorials/r_tutorial/","page":"Using OMOPCDMCohortCreator with R 🏴‍☠️","title":"Using OMOPCDMCohortCreator with R 🏴‍☠️","text":"We will have to install them as follows from within R:","category":"page"},{"location":"tutorials/r_tutorial/","page":"Using OMOPCDMCohortCreator with R 🏴‍☠️","title":"Using OMOPCDMCohortCreator with R 🏴‍☠️","text":"library(JuliaConnectoR)\n\npkg <- juliaImport(\"Pkg\")\n\npkg$activate(\"TUTORIAL\", shared = TRUE) \n# NOTE: You could specify the path to where your project is or any other path you want; set `shared` to `FALSE` if you do\n\npkg$add(c(\"HealthSampleData\", \"OMOPCDMCohortCreator\", \"SQLite\"))","category":"page"},{"location":"tutorials/r_tutorial/","page":"Using OMOPCDMCohortCreator with R 🏴‍☠️","title":"Using OMOPCDMCohortCreator with R 🏴‍☠️","text":"To read more on these packages and what they do, see the appendix for details.","category":"page"},{"location":"tutorials/r_tutorial/#Activating-Analysis-Environment","page":"Using OMOPCDMCohortCreator with R 🏴‍☠️","title":"Activating Analysis Environment","text":"","category":"section"},{"location":"tutorials/r_tutorial/","page":"Using OMOPCDMCohortCreator with R 🏴‍☠️","title":"Using OMOPCDMCohortCreator with R 🏴‍☠️","text":"Now within R, anytime you want to use these installed packages, do the following:","category":"page"},{"location":"tutorials/r_tutorial/","page":"Using OMOPCDMCohortCreator with R 🏴‍☠️","title":"Using OMOPCDMCohortCreator with R 🏴‍☠️","text":"library(JuliaConnectoR)\n\npkg <- juliaImport(\"Pkg\")\npkg$activate(\"TUTORIAL\", shared = TRUE) ","category":"page"},{"location":"tutorials/r_tutorial/#Data","page":"Using OMOPCDMCohortCreator with R 🏴‍☠️","title":"Data","text":"","category":"section"},{"location":"tutorials/r_tutorial/","page":"Using OMOPCDMCohortCreator with R 🏴‍☠️","title":"Using OMOPCDMCohortCreator with R 🏴‍☠️","text":"For this tutorial, we will work with data from Eunomia that is stored in a SQLite format.","category":"page"},{"location":"tutorials/r_tutorial/","page":"Using OMOPCDMCohortCreator with R 🏴‍☠️","title":"Using OMOPCDMCohortCreator with R 🏴‍☠️","text":"hsd <- juliaImport(\"HealthSampleData\")\n\neunomia <- hsd$Eunomia()","category":"page"},{"location":"tutorials/r_tutorial/","page":"Using OMOPCDMCohortCreator with R 🏴‍☠️","title":"Using OMOPCDMCohortCreator with R 🏴‍☠️","text":"NOTE: An internet connection will be needed to download this data. After this data is downloaded, internet is no longer required for this tutorial.","category":"page"},{"location":"tutorials/r_tutorial/#Create-Database-Connection-to-Eunomia","page":"Using OMOPCDMCohortCreator with R 🏴‍☠️","title":"Create Database Connection to Eunomia 💾","text":"","category":"section"},{"location":"tutorials/r_tutorial/","page":"Using OMOPCDMCohortCreator with R 🏴‍☠️","title":"Using OMOPCDMCohortCreator with R 🏴‍☠️","text":"After you have finished your set up in R, we need to establish a connection to the Eunomia SQLite database that we will use for the rest of the tutorial: ","category":"page"},{"location":"tutorials/r_tutorial/","page":"Using OMOPCDMCohortCreator with R 🏴‍☠️","title":"Using OMOPCDMCohortCreator with R 🏴‍☠️","text":"slt <- juliaImport(\"SQLite\")\n\nconn <- slt$DB(eunomia)","category":"page"},{"location":"tutorials/r_tutorial/","page":"Using OMOPCDMCohortCreator with R 🏴‍☠️","title":"Using OMOPCDMCohortCreator with R 🏴‍☠️","text":"With Eunomia, the database's schema is simply called \"main\". We will use this to generate database connection details that OMOPCDMCohortCreator will use internally. For this step, we will use OMOPCDMCohortCreator:","category":"page"},{"location":"tutorials/r_tutorial/","page":"Using OMOPCDMCohortCreator with R 🏴‍☠️","title":"Using OMOPCDMCohortCreator with R 🏴‍☠️","text":"occ <- juliaImport(\"OMOPCDMCohortCreator\")\n\nocc$GenerateDatabaseDetails(juliaEval(\":sqlite\"), \"main\")","category":"page"},{"location":"tutorials/r_tutorial/","page":"Using OMOPCDMCohortCreator with R 🏴‍☠️","title":"Using OMOPCDMCohortCreator with R 🏴‍☠️","text":"Finally, we will generate internal representations of each table found within Eunomia for OMOPCDMCohortCreator to use:","category":"page"},{"location":"tutorials/r_tutorial/","page":"Using OMOPCDMCohortCreator with R 🏴‍☠️","title":"Using OMOPCDMCohortCreator with R 🏴‍☠️","text":"occ$GenerateTables(conn)","category":"page"},{"location":"tutorials/r_tutorial/","page":"Using OMOPCDMCohortCreator with R 🏴‍☠️","title":"Using OMOPCDMCohortCreator with R 🏴‍☠️","text":"As a check to make sure everything was correctly installed and works properly, the following block should work and return a list of all person ids in this data:","category":"page"},{"location":"tutorials/r_tutorial/","page":"Using OMOPCDMCohortCreator with R 🏴‍☠️","title":"Using OMOPCDMCohortCreator with R 🏴‍☠️","text":"occ$GetDatabasePersonIDs(conn) ","category":"page"},{"location":"tutorials/r_tutorial/#Characterization-Analysis","page":"Using OMOPCDMCohortCreator with R 🏴‍☠️","title":"Characterization Analysis 🤒","text":"","category":"section"},{"location":"tutorials/r_tutorial/#Background-for-Analysis","page":"Using OMOPCDMCohortCreator with R 🏴‍☠️","title":"Background for Analysis","text":"","category":"section"},{"location":"tutorials/r_tutorial/","page":"Using OMOPCDMCohortCreator with R 🏴‍☠️","title":"Using OMOPCDMCohortCreator with R 🏴‍☠️","text":"As all the tools are working properly, let's do what is called a characterization study - a study that characterizes a group of patients with a certain condition (or conditions) across various attributes like race, age, and combinations thereof. We are going to do miniature version of such a study looking at patients with strep throat. For this, we will use the condition_concept_id, 28060.","category":"page"},{"location":"tutorials/r_tutorial/#Task:-Find-All-Patients-with-Strep-Throat","page":"Using OMOPCDMCohortCreator with R 🏴‍☠️","title":"Task: Find All Patients with Strep Throat","text":"","category":"section"},{"location":"tutorials/r_tutorial/","page":"Using OMOPCDMCohortCreator with R 🏴‍☠️","title":"Using OMOPCDMCohortCreator with R 🏴‍☠️","text":"strep_patients <- occ$ConditionFilterPersonIDs(28060, conn)\nstrep_patients <- strep_patients$person_id","category":"page"},{"location":"tutorials/r_tutorial/#Task:-Find-the-Race-of-Patients-with-Strep-Throat","page":"Using OMOPCDMCohortCreator with R 🏴‍☠️","title":"Task: Find the Race of Patients with Strep Throat","text":"","category":"section"},{"location":"tutorials/r_tutorial/","page":"Using OMOPCDMCohortCreator with R 🏴‍☠️","title":"Using OMOPCDMCohortCreator with R 🏴‍☠️","text":"strep_patients_race <- occ$GetPatientRace(strep_patients, conn)","category":"page"},{"location":"tutorials/r_tutorial/#Task:-Find-the-Gender-of-Patients-with-Strep-Throat","page":"Using OMOPCDMCohortCreator with R 🏴‍☠️","title":"Task: Find the Gender of Patients with Strep Throat","text":"","category":"section"},{"location":"tutorials/r_tutorial/","page":"Using OMOPCDMCohortCreator with R 🏴‍☠️","title":"Using OMOPCDMCohortCreator with R 🏴‍☠️","text":"strep_patients_gender <- occ$GetPatientGender(strep_patients, conn)","category":"page"},{"location":"tutorials/r_tutorial/#Task:-Create-Age-Groupings-of-Patients-with-Strep-Throat","page":"Using OMOPCDMCohortCreator with R 🏴‍☠️","title":"Task: Create Age Groupings of Patients with Strep Throat","text":"","category":"section"},{"location":"tutorials/r_tutorial/","page":"Using OMOPCDMCohortCreator with R 🏴‍☠️","title":"Using OMOPCDMCohortCreator with R 🏴‍☠️","text":"For this task, for every single person who has a strep throat diagnosis, we need to assign them an age group. For this demo, age groupings will be made along 5 year intervals when assigned to a person up to 100 years of age (e.g. 0 4 5 9  95 100).","category":"page"},{"location":"tutorials/r_tutorial/","page":"Using OMOPCDMCohortCreator with R 🏴‍☠️","title":"Using OMOPCDMCohortCreator with R 🏴‍☠️","text":"age_groups <- list(\n\tlist(0, 4),\n\tlist(5, 9),\n\tlist(10, 14),\n\tlist(15, 19),\n\tlist(20, 24),\n\tlist(25, 29),\n\tlist(30, 34),\n\tlist(35, 39),\n\tlist(40, 44),\n\tlist(45, 49),\n\tlist(50, 54),\n\tlist(55, 59),\n\tlist(60, 64),\n\tlist(65, 69),\n\tlist(70, 74),\n\tlist(75, 79),\n\tlist(80, 84),\n\tlist(85, 89),\n\tlist(90, 94),\n\tlist(95, 99))\n\nstrep_patients_age_group <- occ$GetPatientAgeGroup(strep_patients, conn, age_groupings = age_groups)","category":"page"},{"location":"tutorials/r_tutorial/#Task:-Characterize-Each-Person-by-Gender,-Race,-and-Age-Group","page":"Using OMOPCDMCohortCreator with R 🏴‍☠️","title":"Task: Characterize Each Person by Gender, Race, and Age Group","text":"","category":"section"},{"location":"tutorials/r_tutorial/","page":"Using OMOPCDMCohortCreator with R 🏴‍☠️","title":"Using OMOPCDMCohortCreator with R 🏴‍☠️","text":"With the previous tasks, we now know patients' gender, race, and age group. Using this information, we can combine these features to create a final table showing each patient's person_id, gender, race, and age group per row. To do this combining, we will use the dplyr and tibble packages:","category":"page"},{"location":"tutorials/r_tutorial/","page":"Using OMOPCDMCohortCreator with R 🏴‍☠️","title":"Using OMOPCDMCohortCreator with R 🏴‍☠️","text":"library(dplyr)\nlibrary(tibble)\n\nstrep_patients <- tibble(data.frame(person_id=strep_patients))\nstrep_patients_race <- tibble(data.frame(strep_patients_race))\nstrep_patients_gender <- tibble(data.frame(strep_patients_gender))\nstrep_patients_age_group <- tibble(data.frame(strep_patients_age_group))","category":"page"},{"location":"tutorials/r_tutorial/#Task:-Create-Patient-Groupings","page":"Using OMOPCDMCohortCreator with R 🏴‍☠️","title":"Task: Create Patient Groupings","text":"","category":"section"},{"location":"tutorials/r_tutorial/","page":"Using OMOPCDMCohortCreator with R 🏴‍☠️","title":"Using OMOPCDMCohortCreator with R 🏴‍☠️","text":"Often with characterization style studies, it is extremely important to aggregate patient populations. This is to protect the anonymity of patients with perhaps severely sensitive conditions (e.g. mental illnesses, sexually transmitted diseases, etc.) from possible repercussions from accidental disclosure of this patient information.","category":"page"},{"location":"tutorials/r_tutorial/","page":"Using OMOPCDMCohortCreator with R 🏴‍☠️","title":"Using OMOPCDMCohortCreator with R 🏴‍☠️","text":"final_df <- full_join(strep_patients, strep_patients_race, by = c(\"person_id\" = \"person_id\")) %>% \nfull_join(strep_patients_age_group, by = c(\"person_id\" = \"person_id\")) %>%\nfull_join(strep_patients_gender, by = c(\"person_id\" = \"person_id\")) %>%\nselect(-person_id) %>% \ncount(race_concept_id, age_group, gender_concept_id) %>%\nrename(count = \"n\") %>%\nfilter(count > 10)","category":"page"},{"location":"tutorials/r_tutorial/#Conclusion","page":"Using OMOPCDMCohortCreator with R 🏴‍☠️","title":"Conclusion 🎉","text":"","category":"section"},{"location":"tutorials/r_tutorial/","page":"Using OMOPCDMCohortCreator with R 🏴‍☠️","title":"Using OMOPCDMCohortCreator with R 🏴‍☠️","text":"This mini characterization study that we just conducted on this dataset opens up a whole new avenue for a researcher to pursue. For example, we could now calculate prevalence rates across different patient characteristics or compare and contrast multiple conditions at once. It should also be apparent that the API is set up in a very particular way: it is functional meaning that each function does one thing only. This gives a lot of flexibility to a user to build together a study incrementally using OMOPCDMCohortCreator.","category":"page"},{"location":"tutorials/r_tutorial/#Appendix","page":"Using OMOPCDMCohortCreator with R 🏴‍☠️","title":"Appendix 🕵️","text":"","category":"section"},{"location":"tutorials/r_tutorial/#Packages-Used-in-Analysis","page":"Using OMOPCDMCohortCreator with R 🏴‍☠️","title":"Packages Used in Analysis","text":"","category":"section"},{"location":"tutorials/r_tutorial/#R-Packages-Used:","page":"Using OMOPCDMCohortCreator with R 🏴‍☠️","title":"R Packages Used:","text":"","category":"section"},{"location":"tutorials/r_tutorial/","page":"Using OMOPCDMCohortCreator with R 🏴‍☠️","title":"Using OMOPCDMCohortCreator with R 🏴‍☠️","text":"dplyr - grammar of data manipulation\ntibble - modern reimagining of the data.frame\nJuliaConnectoR - a functionally oriented interface for calling Julia from R","category":"page"},{"location":"tutorials/r_tutorial/#Julia-Packages-Used:","page":"Using OMOPCDMCohortCreator with R 🏴‍☠️","title":"Julia Packages Used:","text":"","category":"section"},{"location":"tutorials/r_tutorial/","page":"Using OMOPCDMCohortCreator with R 🏴‍☠️","title":"Using OMOPCDMCohortCreator with R 🏴‍☠️","text":"OMOPCDMCohortCreator - Create cohorts from databases utilizing the OMOP CDM\nHealthSampleData - Sample health data for a variety of health formats and use cases\nSQLite - A Julia interface to the SQLite library","category":"page"},{"location":"#Welcome-to-the-OMOPCDMCohortCreator.jl-Docs!","page":"Home","title":"Welcome to the OMOPCDMCohortCreator.jl Docs! 👋","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Create cohorts from databases utilizing the OMOP CDM.","category":"page"},{"location":"","page":"Home","title":"Home","text":"This package uses a functional approach to query databases in the OMOP Common Data Model format whereby you could build rapidly lines of inquiry into the database. Furthermore, this package is a companion to those tools found in the HADES ecosystem. To get started, visit the Tutorials section as well as visit the API section to see all the functions available. If you want to contribute, please check out our Contributing guide!","category":"page"},{"location":"#Main-Features","page":"Home","title":"Main Features 🔧","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The biggest features of this package are:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Incremental building blocks for creating an analysis pipeline in the form of (more information in API):\n\"Getter\" functions to \"get\" information from a database \n\"Filter\" functions to \"filter\" information from a database \n\"Generator\" functions to \"generate\" database information and connections\n\"Executor\" functions to \"execute\" on retrieved information \nAutomatic targeting and support for the SQL flavors (via FunSQL.jl):\npostgresql\nsqlite\nredshift\nPrepare SQL queries if unable to connect to database via OMOPCDMCohortCreator that could then be run on a given SQL database directly\nDoes not mutate database or require temp tables\nInteroperable with the R language via JuliaConnectoR to work directly within R syntax (see Tutorials)\nReadily parallelizable via Distributed.jl\nComplementary to OHDSI HADES ecosystem tools\nExtensive test suite to ensure correctness and compliance with privacy preserving methods (HITECH, etc.)","category":"page"},{"location":"#Why?","page":"Home","title":"Why? 🤔","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package was created as the result of work in the MentalHealthEquity network study. Phenotype definitions work alongside this package and OMOPCDMCohortCreator allows an investigator to quickly iterate and build on top of phenotype definitions and/or concept sets. Where I personally see this being of use is when an investigator needs to quickly pull information out of a database, iterate and test ideas for a formal phenotype definition rapidly, and reason simply about queries.","category":"page"},{"location":"#Why-Julia?","page":"Home","title":"Why Julia? 🤓","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Julia itself is built for High Performance Computing and readability. We wanted to work in a language that could handle the high amounts of data that could manifest in working with OMOP CDM databases. Julia not only made sense for \"big data\" operations and readability but also was attractive due to it's ability to work with other programming languages such as R or Python. Therefore, the benefit is:","category":"page"},{"location":"","page":"Home","title":"Home","text":"High performance more easily reached on all ranges of hardware\nLower barrier to entry for new contributors\nInteroperation with other programming languages","category":"page"},{"location":"","page":"Home","title":"Home","text":"In our eyes, we do not see anything lost by choosing Julia as we can easily bridge to other languages. The idea is that this approach can keep users in the language they are comfortable with while working with a flexible package to quickly perform analyses.","category":"page"}]
}
